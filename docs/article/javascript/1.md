# 垃圾代码和优质代码的区别-1

几个实际应用场景重构示例

## 请求顺序依赖

有a,b,c,d四个请求，c依赖b的结果，d依赖abc三个的结果，错误的代码如下：

```js
function a(callback) {
    ajax(url, function(res) {
        callback(res);
    })
}

function b(callback) {
    ajax(url, function(res) {
        callback(res);
    })
}

function c(b, callback) {
    ajax(url, function(res) {
        callback(res);
    })
}

function d(a, b, c, callback) {
    ajax(url, function(res) {
        callback(res);
    })
}

a(function(resa) {
    b(function(resb) {
        c(resb, function(resc) {
            d(resa, resb, resc, function(resd) {
                console.log("result:" + resd);
            })
        })
    })
})
```
以上就形成了回调地狱，而没有考虑a和b是可以并发执行的，随着js的进化，es5到es6，有了callback->Promise->generator + co ->async + await，js从语法层面不断去简化对异步的控制能力

这里直接给出目前原生js提供的终极方案：基于Promise + async/await

正确示例：
```js
function a() {
    return new Promise((resolve, reject) => {
        ajax(url, function(res) {
            resolve(res);
        }, function (err) {
            reject(err);
        })
    })
}

function b() {
    return new Promise((resolve, reject) => {
        ajax(url, function(res) {
            resolve(res);
        }, function (err) {
            reject(err);
        })
    })
}

function c() {
    return new Promise((resolve, reject) => {
        ajax(url, function(res) {
            resolve(res);
        }, function (err) {
            reject(err);
        })
    })
}

function d() {
    return new Promise((resolve, reject) => {
        ajax(url, function(res) {
            resolve(res);
        }, function (err) {
            reject(err);
        })
    })
}
```
